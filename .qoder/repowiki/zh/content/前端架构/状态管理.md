# 状态管理

<cite>
**本文档中引用的文件**   
- [use-toast.ts](file://hooks/use-toast.ts)
- [sonner.tsx](file://components/ui/sonner.tsx)
- [toaster.tsx](file://components/ui/toaster.tsx)
- [toast.tsx](file://components/ui/toast.tsx)
- [auth.ts](file://lib/auth.ts)
- [login/route.ts](file://app/api/auth/login/route.ts)
- [logout/route.ts](file://app/api/auth/logout/route.ts)
- [register/route.ts](file://app/api/auth/register/route.ts)
- [middleware.ts](file://middleware.ts)
- [EventDialog.tsx](file://components/EventDialog.tsx)
- [ReminderRuleDialog.tsx](file://components/ReminderRuleDialog.tsx)
- [layout.tsx](file://app/layout.tsx)
- [calendar/page.tsx](file://app/calendar/page.tsx)
</cite>

## 目录
1. [简介](#简介)
2. [全局通知状态管理](#全局通知状态管理)
3. [用户认证状态管理](#用户认证状态管理)
4. [全局UI状态管理](#全局ui状态管理)
5. [状态持久化与跨组件通信](#状态持久化与跨组件通信)
6. [错误状态处理策略](#错误状态处理策略)
7. [典型使用场景](#典型使用场景)
8. [总结](#总结)

## 简介
本项目采用多种状态管理机制来处理不同类型的应用状态。系统通过自定义Hook `use-toast` 与 Sonner 库集成实现全局通知状态管理，使用 JWT 存储于 HTTP Only Cookie 中进行用户认证状态管理，并通过 props 传递和回调函数控制全局UI状态（如对话框的打开/关闭）。这些机制共同构成了一个完整、安全且用户友好的状态管理体系。

## 全局通知状态管理

项目中的全局通知状态管理基于自定义Hook `use-toast.ts` 与 Sonner 库的深度集成。该机制实现了通知状态的发布、消费和生命周期管理。

```mermaid
flowchart TD
A["触发通知<br/>toast({...})"] --> B["生成唯一ID<br/>genId()"]
B --> C["创建通知对象<br/>包含title/description等"]
C --> D["分发ADD_TOAST动作<br/>dispatch()"]
D --> E["更新内存状态<br/>reducer处理"]
E --> F["通知监听器<br/>listeners.forEach()"]
F --> G["更新React状态<br/>setState()"]
G --> H["UI渲染通知<br/>Toaster组件"]
H --> I["用户交互<br/>点击/关闭"]
I --> J["分发DISMISS_TOAST<br/>dispatch()"]
J --> K["添加到移除队列<br/>addToRemoveQueue()"]
K --> L["定时移除通知<br/>setTimeout()"]
L --> M["分发REMOVE_TOAST<br/>dispatch()"]
```

**Diagram sources**
- [use-toast.ts](file://hooks/use-toast.ts#L1-L191)
- [toaster.tsx](file://components/ui/toaster.tsx#L1-L36)

**Section sources**
- [use-toast.ts](file://hooks/use-toast.ts#L1-L191)
- [sonner.tsx](file://components/ui/sonner.tsx#L1-L41)
- [toaster.tsx](file://components/ui/toaster.tsx#L1-L36)

## 用户认证状态管理

用户认证状态通过JWT存储于HTTP Only Cookie中进行管理，结合中间件在服务端进行身份验证，并将用户状态通过API暴露给客户端。

```mermaid
sequenceDiagram
participant Client as "客户端"
participant Middleware as "中间件"
participant AuthAPI as "认证API"
participant Server as "服务器"
Client->>AuthAPI : 登录请求(邮箱/密码)
AuthAPI->>Server : 验证用户凭证
Server-->>AuthAPI : 用户信息
AuthAPI->>AuthAPI : 生成JWT令牌
AuthAPI-->>Client : 设置HTTP Only Cookie
Client->>Server : 后续请求
Middleware->>Middleware : 检查Cookie中的JWT
Middleware->>Middleware : 验证令牌有效性
alt 令牌有效
Middleware-->>Server : 继续请求处理
else 令牌无效
Middleware-->>Client : 重定向到登录页
Middleware->>Client : 删除无效Cookie
end
```

**Diagram sources**
- [auth.ts](file://lib/auth.ts#L1-L30)
- [login/route.ts](file://app/api/auth/login/route.ts#L1-L57)
- [middleware.ts](file://middleware.ts#L1-L50)

**Section sources**
- [auth.ts](file://lib/auth.ts#L1-L30)
- [login/route.ts](file://app/api/auth/login/route.ts#L1-L57)
- [logout/route.ts](file://app/api/auth/logout/route.ts#L1-L13)
- [register/route.ts](file://app/api/auth/register/route.ts#L1-L53)
- [middleware.ts](file://middleware.ts#L1-L50)

## 全局UI状态管理

全局UI状态（如对话框打开/关闭）通过props传递与回调函数进行控制，实现了父子组件之间的状态同步。

```mermaid
flowchart TD
A["父组件<br/>CalendarPage"] --> B["UI状态变量<br/>dialogOpen: boolean"]
A --> C["回调函数<br/>handleDialogOpenChange"]
B --> D["传递给子组件<br/>EventDialog"]
C --> E["传递给子组件<br/>onOpenChange"]
D --> F["子组件接收props<br/>open, onOpenChange"]
F --> G["控制对话框显示<br/>Dialog open={open}"]
G --> H["用户交互事件<br/>关闭按钮/点击遮罩"]
H --> I["调用回调函数<br/>onOpenChange(false)"]
I --> J["更新父组件状态<br/>setDialogOpen(false)"]
J --> K["状态同步完成"]
```

**Diagram sources**
- [EventDialog.tsx](file://components/EventDialog.tsx#L1-L227)
- [calendar/page.tsx](file://app/calendar/page.tsx#L1-L468)

**Section sources**
- [EventDialog.tsx](file://components/EventDialog.tsx#L1-L227)
- [ReminderRuleDialog.tsx](file://components/ReminderRuleDialog.tsx#L1-L173)
- [calendar/page.tsx](file://app/calendar/page.tsx#L1-L468)

## 状态持久化与跨组件通信

系统通过多种机制实现状态持久化和跨组件通信，确保状态在不同组件间的一致性和持久性。

### 状态持久化机制
- **HTTP Only Cookie**: 用于持久化JWT令牌，防止XSS攻击
- **内存状态**: `use-toast` 使用内存变量 `memoryState` 持久化通知状态
- **浏览器存储**: 通过Service Worker实现通知状态的后台持久化

### 跨组件通信模式
- **自定义Hook**: `use-toast` 作为全局状态管理器，允许多个组件订阅和发布通知
- **Props传递**: 通过组件props传递状态和回调函数
- **事件系统**: 基于监听器模式的发布-订阅系统

```mermaid
classDiagram
class useToast {
+toasts : ToasterToast[]
+toast() : ToastReturn
+dismiss() : void
-reducer() : State
-dispatch() : void
-listeners : Array
-memoryState : State
}
class Toaster {
+useToast() : Hook
+render() : JSX
}
class EventDialog {
+open : boolean
+onOpenChange() : void
+useToast() : Hook
}
class CalendarPage {
+dialogOpen : boolean
+handleDialogOpenChange() : void
}
useToast <.. Toaster : "使用"
useToast <.. EventDialog : "使用"
CalendarPage --> EventDialog : "传递props"
useToast <-- Toaster : "状态消费"
useToast <-- EventDialog : "状态消费"
```

**Diagram sources**
- [use-toast.ts](file://hooks/use-toast.ts#L1-L191)
- [toaster.tsx](file://components/ui/toaster.tsx#L1-L36)
- [EventDialog.tsx](file://components/EventDialog.tsx#L1-L227)

**Section sources**
- [use-toast.ts](file://hooks/use-toast.ts#L1-L191)
- [toaster.tsx](file://components/ui/toaster.tsx#L1-L36)
- [layout.tsx](file://app/layout.tsx#L1-L40)

## 错误状态处理策略

系统实现了全面的错误状态处理策略，确保用户体验的健壮性和友好性。

### 错误处理层级
1. **API层错误处理**: 在API路由中捕获和处理错误
2. **组件层错误处理**: 在组件中使用try-catch处理异步操作
3. **全局错误处理**: 通过通知系统向用户展示错误信息

### 错误状态管理特点
- **用户友好**: 将技术性错误信息转换为用户可理解的提示
- **一致性**: 统一的错误通知样式和位置
- **可恢复性**: 提供明确的恢复路径或重试选项

```mermaid
flowchart TD
A["异步操作开始"] --> B["try-catch包裹"]
B --> C["操作成功"]
C --> D["显示成功通知"]
B --> E["捕获异常"]
E --> F["判断错误类型"]
F --> G["网络错误"]
F --> H["验证错误"]
F --> I["服务器错误"]
G --> J["显示离线提示"]
H --> K["显示表单验证错误"]
I --> L["显示通用错误通知"]
J --> M["用户反馈"]
K --> M
L --> M
```

**Diagram sources**
- [EventDialog.tsx](file://components/EventDialog.tsx#L1-L227)
- [ReminderRuleDialog.tsx](file://components/ReminderRuleDialog.tsx#L1-L173)
- [settings/page.tsx](file://app/settings/page.tsx#L145-L181)

**Section sources**
- [EventDialog.tsx](file://components/EventDialog.tsx#L1-L227)
- [ReminderRuleDialog.tsx](file://components/ReminderRuleDialog.tsx#L1-L173)
- [settings/page.tsx](file://app/settings/page.tsx#L145-L181)

## 典型使用场景

### 通知系统的使用场景
在 `EventDialog` 组件中，当用户成功创建或更新日程时，系统会发布一个成功通知：

```mermaid
sequenceDiagram
participant User as "用户"
participant EventDialog as "EventDialog"
participant useToast as "useToast"
participant Toaster as "Toaster"
User->>EventDialog : 提交表单
EventDialog->>EventDialog : 发送API请求
EventDialog->>useToast : toast({title : "日程已创建"})
useToast->>useToast : 生成ID并分发ADD_TOAST
useToast->>Toaster : 状态更新
Toaster->>Toaster : 渲染通知UI
Toaster->>User : 显示成功通知
```

### 认证状态的使用场景
当用户访问受保护的路由时，中间件会验证其认证状态：

```mermaid
sequenceDiagram
participant User as "用户"
participant Middleware as "中间件"
participant Browser as "浏览器"
User->>Middleware : 访问/calendar
Middleware->>Browser : 检查token Cookie
alt 存在有效token
Middleware-->>User : 允许访问
else 不存在或无效token
Middleware->>Browser : 重定向到/login
Middleware->>Browser : 删除无效token
Browser-->>User : 显示登录页
end
```

**Section sources**
- [EventDialog.tsx](file://components/EventDialog.tsx#L1-L227)
- [calendar/page.tsx](file://app/calendar/page.tsx#L1-L468)
- [middleware.ts](file://middleware.ts#L1-L50)

## 总结
本项目的状态管理机制设计合理，涵盖了通知、认证和UI状态等多个方面。通过自定义Hook `use-toast` 实现了高效的全局通知管理，利用HTTP Only Cookie和中间件确保了认证状态的安全性，采用props传递和回调函数的方式实现了UI状态的精确控制。这些机制共同构建了一个健壮、安全且用户友好的应用状态管理体系。